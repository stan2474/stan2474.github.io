<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>roblox::utils</title>
<style>
body {
  font-family: "Courier New", Courier, monospace;
  background-color: #121212;
  color: #e0e0e0;
  line-height: 1.6;
  margin: 0;
  padding: 2em;
}
.container {
  max-width: 760px;
  margin: 0 auto;
}
h1, h2 {
  font-weight: normal;
  border-bottom: 1px solid #444;
  padding-bottom: 0.3em;
  margin-top: 1.5em;
  margin-bottom: 1em;
}
hr {
  border: none;
  border-top: 1px solid #444;
  margin: 2em 0;
}
.drop-zone {
  border: 2px dashed #444;
  padding: 3em;
  text-align: center;
  cursor: pointer;
  margin-bottom: 1em;
  transition: border-color 0.2s, background-color 0.2s;
}
.drop-zone.dragover {
  border-color: #888;
  background-color: #1a1a1a;
}
button, .btn {
  font-family: inherit;
  font-size: 1em;
  padding: 0.5em 1em;
  background-color: #2a2a2a;
  color: #e0e0e0;
  border: 1px solid #555;
  cursor: pointer;
  margin-right: 0.5em;
  margin-top: 0.5em;
}
button:hover, .btn:hover {
  background-color: #333;
  border-color: #777;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: #2a2a2a;
  border-color: #555;
}
.status-text.ready {
  color: #81c784;
}
.status-text.error {
  color: #e57373;
}
.console-window {
  background-color: #0d0d0d;
  border: 1px solid #444;
  border-radius: 4px;
  overflow: hidden;
}
.console-header {
  background-color: #2a2a2a;
  padding: 4px 8px;
  font-size: 0.8em;
  color: #aaa;
  border-bottom: 1px solid #444;
  text-transform: lowercase;
}
.console {
  width: 100%;
  box-sizing: border-box;
  height: 220px;
  font-family: "Courier New", monospace;
  font-size: 0.9em;
  color: #ccc;
  padding: 0.5em;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}
.log-entry {
  margin-bottom: 2px;
}
input[type="checkbox"], select {
  vertical-align: middle;
  margin-right: 0.5em;
}
input[type="text"] {
    font-family: inherit;
    background-color: #1a1a1a;
    color: #e0e0e0;
    border: 1px solid #444;
    padding: 0.4em;
    font-size: 0.9em;
}
select {
    font-family: inherit;
    background-color: #2a2a2a;
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 0.3em;
}
.setting-item {
  margin-bottom: 0.5em;
}
.footer {
  margin-top: 2em;
  font-size: 0.9em;
  color: #777;
  text-align: center;
}
.back-link {
    display: inline-block;
    margin-bottom: 1em;
    color: #aaccff;
    text-decoration: none;
}
.back-link:hover {
    text-decoration: underline;
}
.mapping-item {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-bottom: 0.5em;
}
.mapping-item input[type="text"] {
    flex: 1;
}
.mapping-item span {
    color: #888;
}
.remove-mapping-btn {
    padding: 0.2em 0.6em;
    font-size: 1.2em;
    line-height: 1;
    background-color: #3a2a2a;
    border-color: #755;
}
.remove-mapping-btn:hover {
    background-color: #5a2a2a;
    border-color: #a55;
    color: #fdd;
}
.mapping-controls {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-top: 1em;
}
.mapping-controls button {
    margin-top: 0;
}
a {
  color: #aaccff;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
a:visited {
  color: #e0b3ff;
}
</style>
</head>
<body>

<div class="container">

<div id="page-home">
  <h1>roblox::utils</h1>
  <p>choose a utility to use.</p>
  <button id="goto-place-converter">legacy_place::convert</button>
  <button id="goto-obj-to-mesh-converter">obj::to_roblox_mesh</button>
  <button id="goto-mesh-to-obj-converter">roblox_mesh::to_obj</button>
  <button id="goto-mesh-version-converter">roblox_mesh::to_roblox_mesh</button>

  <hr>

  <h2>credits</h2>
  <ul>
    <li>
      <strong>legacy_place::convert</strong> uses <a href="https://github.com/rojo-rbx/rbx-dom" target="_blank" rel="noopener noreferrer">rbx-binary and rbx_xml</a> 
      (from rbx-dom) for roblox place file conversion.
    </li>
    <li>
      <strong>obj::to_roblox_mesh / roblox_mesh::to_obj</strong> is based on 
      <a href="https://devforum.roblox.com/t/roblox-filemesh-format-specification/326114/" target="_blank" rel="noopener noreferrer">maximumadhd's roblox mesh file format documentation</a>.
    </li>
  </ul>
</div>

  <div id="page-place-converter" style="display: none;">
    <a href="#" class="back-link">&larr; back to home</a>
    <h1>legacy_place::convert</h1>
    <p>a utility to make modern roblox places work on legacy roblox clients</p>
    
    <div id="drop-place" class="drop-zone" tabindex="0">
      <p id="drop-hint-place">drag & drop a .rbxl or .rbxlx file here, or click to choose.</p>
      <p id="filename-place"></p>
    </div>
    
    <input id="fileinput-place" type="file" accept=".rbxl,.rbxlx" style="display:none" />
    <button id="choosebtn-place">choose file</button>
    <button id="convertbtn-place" disabled>convert & download</button>
    <p id="status-place">status: <span id="status-text-place" class="status-text">idle</span></p>
  
    <hr>
  
    <h2>settings</h2>
    <div class="setting-item">
      <label>
        <input type="checkbox" id="toggle-folders">
        convert folder instances into models
      </label>
    </div>
    <div class="setting-item">
      <label>
        <input type="checkbox" id="toggle-meshparts">
        convert meshparts into part + specialmesh
      </label>
    </div>
    <div class="setting-item">
      <label>
        <input type="checkbox" id="toggle-xml">
        force export to xml (.rbxlx)
      </label>
    </div>
    <div class="setting-item">
      <label>
        <input type="checkbox" id="toggle-binary">
        force export to binary (.rbxl)
      </label>
    </div>
    <div class="setting-item">
      <label>
        <input type="checkbox" id="toggle-assetid-to-url">
        convert rbxassetid:// to url
      </label>
    </div>
    <div class="setting-item" id="asset-url-format-container" style="display: none; margin-left: 2em;">
      <label for="asset-url-format-input">url: </label>
      <input type="text" id="asset-url-format-input" value="http://www.roblox.com/asset/?id=" size="40">
    </div>

    <hr>

    <h2>instance mapping</h2>
    <p>replace specific instance classnames with others. (e.g., "Folder" &rarr; "Model")</p>
    <div id="instance-mappings-list">
    </div>
    <div class="mapping-controls">
        <button id="add-mapping-btn">+ add mapping</button>
        <button id="import-config-btn">import config</button>
        <button id="export-config-btn">export config</button>
        <input type="file" id="import-config-input" accept=".json" style="display:none;" />
    </div>
  
    <hr>
  
    <h2>console</h2>
    <div class="console-window">
      <div class="console-header"><span>output</span></div>
      <div id="console-place" class="console" tabindex="0"></div>
    </div>
  </div>

  <div id="page-obj-to-mesh-converter" style="display: none;">
    <a href="#" class="back-link">&larr; back to home</a>
    <h1>obj::to_roblox_mesh</h1>
    <p>a utility to convert .obj files to roblox's mesh format</p>
    
    <div id="drop-obj-to-mesh" class="drop-zone" tabindex="0">
      <p id="drop-hint-obj-to-mesh">drag & drop a .obj file here, or click to choose.</p>
      <p id="filename-obj-to-mesh"></p>
    </div>
    
    <input id="fileinput-obj-to-mesh" type="file" accept=".obj" style="display:none" />
    <button id="choosebtn-obj-to-mesh">choose file</button>
    <button id="convertbtn-obj-to-mesh" disabled>convert & download</button>
    <p id="status-obj-to-mesh">status: <span id="status-text-obj-to-mesh" class="status-text">idle</span></p>
  
    <hr>
  
    <h2>settings</h2>
    <div class="setting-item">
      <label for="mesh-version-select">target mesh version:</label>
      <select id="mesh-version-select">
        <option value="v1.00">version 1.00</option>
        <option value="v1.01">version 1.01</option>
        <option value="v2.00" selected>version 2.00</option>
        <option value="v3.00">version 3.00</option>
        <option value="v4.00">version 4.00</option>
        <option value="v5.00">version 5.00</option>
      </select>
    </div>
  
    <hr>
  
    <h2>console</h2>
    <div class="console-window">
      <div class="console-header"><span>output</span></div>
      <div id="console-obj-to-mesh" class="console" tabindex="0"></div>
    </div>
  </div>
  
  <div id="page-mesh-to-obj-converter" style="display: none;">
    <a href="#" class="back-link">&larr; back to home</a>
    <h1>roblox_mesh::to_obj</h1>
    <p>a utility to convert roblox's mesh format back to .obj</p>
    
    <div id="drop-mesh-to-obj" class="drop-zone" tabindex="0">
      <p id="drop-hint-mesh-to-obj">drag & drop a .mesh file here, or click to choose.</p>
      <p id="filename-mesh-to-obj"></p>
    </div>
    
    <input id="fileinput-mesh-to-obj" type="file" accept=".mesh,application/octet-stream" style="display:none" />
    <button id="choosebtn-mesh-to-obj">choose file</button>
    <button id="convertbtn-mesh-to-obj" disabled>convert & download</button>
    <p id="status-mesh-to-obj">status: <span id="status-text-mesh-to-obj" class="status-text">idle</span></p>
  
    <hr>
  
    <h2>console</h2>
    <div class="console-window">
      <div class="console-header"><span>output</span></div>
      <div id="console-mesh-to-obj" class="console" tabindex="0"></div>
    </div>
  </div>

  <div id="page-mesh-version-converter" style="display: none;">
    <a href="#" class="back-link">&larr; back to home</a>
    <h1>roblox_mesh::to_roblox_mesh</h1>
    <p>a utility to upgrade or downgrade your mesh to any version</p>
    
    <div id="drop-mesh-version" class="drop-zone" tabindex="0">
      <p id="drop-hint-mesh-version">drag & drop a .mesh file here, or click to choose.</p>
      <p id="filename-mesh-version"></p>
    </div>
    
    <input id="fileinput-mesh-version" type="file" accept=".mesh,application/octet-stream" style="display:none" />
    <button id="choosebtn-mesh-version">choose file</button>
    <button id="convertbtn-mesh-version" disabled>convert & download</button>
    <p id="status-mesh-version">status: <span id="status-text-mesh-version" class="status-text">idle</span></p>
  
    <hr>
  
    <h2>settings</h2>
    <div class="setting-item">
      <label for="mesh-version-select-target">target mesh version:</label>
      <select id="mesh-version-select-target">
        <option value="v1.00">version 1.00</option>
        <option value="v1.01">version 1.01</option>
        <option value="v2.00" selected>version 2.00</option>
        <option value="v3.00">version 3.00</option>
        <option value="v4.00">version 4.00</option>
        <option value="v5.00">version 5.00</option>
      </select>
    </div>
  
    <hr>
  
    <h2>console</h2>
    <div class="console-window">
      <div class="console-header"><span>output</span></div>
      <div id="console-mesh-version" class="console" tabindex="0"></div>
    </div>
  </div>
</div>

<script type="module">
import initWasm, {
  fix_place,
  convert_obj_to_filemesh,
  convert_filemesh_to_obj,
  convert_filemesh_version,
  RobloxMeshVersion
} from './robloxPlaceConverter.js'; // this was originally gonna be just a place converter, but then I added mesh converters too

atob('c3RhbiB3YXMgaGVyZQ==');
const pages = document.querySelectorAll('.container > div');
const backLinks = document.querySelectorAll('.back-link');
const gotoPlaceBtn = document.getElementById('goto-place-converter');
const gotoObjToMeshBtn = document.getElementById('goto-obj-to-mesh-converter');
const gotoMeshToObjBtn = document.getElementById('goto-mesh-to-obj-converter');
const gotoMeshVersionBtn = document.getElementById('goto-mesh-version-converter');

let activeConsole = null;

function showPage(pageId) {
    pages.forEach(p => p.style.display = 'none');
    const targetPage = document.getElementById(pageId);
    if (targetPage) {
        targetPage.style.display = 'block';
        activeConsole = targetPage.querySelector('.console');
    }
}

gotoPlaceBtn.addEventListener('click', () => showPage('page-place-converter'));
gotoObjToMeshBtn.addEventListener('click', () => showPage('page-obj-to-mesh-converter'));
gotoMeshToObjBtn.addEventListener('click', () => showPage('page-mesh-to-obj-converter'));
gotoMeshVersionBtn.addEventListener('click', () => showPage('page-mesh-version-converter'));

backLinks.forEach(link => link.addEventListener('click', (e) => {
    e.preventDefault();
    showPage('page-home');
}));

function appendConsole(msg){
  if (!activeConsole) return;
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  const textContent = typeof msg === 'string' ? msg : JSON.stringify(msg);
  entry.textContent = `> ${textContent}`;
  activeConsole.appendChild(entry);
  activeConsole.scrollTop = activeConsole.scrollHeight;
}

const origConsole = { log: console.log.bind(console), warn: console.warn.bind(console), error: console.error.bind(console) };
console.log = function(...a){ origConsole.log(...a); a.forEach(x=>appendConsole(x)) };
console.warn = function(...a){ origConsole.warn(...a); a.forEach(x=>appendConsole(x)) };
console.error = function(...a){ origConsole.error(...a); a.forEach(x=>appendConsole(x)) };

const placeConverter = {
    dropHint: document.getElementById('drop-hint-place'),
    filenameEl: document.getElementById('filename-place'),
    drop: document.getElementById('drop-place'),
    chooseBtn: document.getElementById('choosebtn-place'),
    fileInput: document.getElementById('fileinput-place'),
    convertBtn: document.getElementById('convertbtn-place'),
    statusText: document.getElementById('status-text-place'),
    toggleFolders: document.getElementById('toggle-folders'),
    toggleMeshParts: document.getElementById('toggle-meshparts'),
    toggleXml: document.getElementById('toggle-xml'),
    toggleBinary: document.getElementById('toggle-binary'),
    toggleAssetIdToUrl: document.getElementById('toggle-assetid-to-url'),
    assetUrlFormatContainer: document.getElementById('asset-url-format-container'),
    assetUrlFormatInput: document.getElementById('asset-url-format-input'),
    mappingsList: document.getElementById('instance-mappings-list'),
    addMappingBtn: document.getElementById('add-mapping-btn'),
    importConfigBtn: document.getElementById('import-config-btn'),
    exportConfigBtn: document.getElementById('export-config-btn'),
    importConfigInput: document.getElementById('import-config-input'),
    currentFile: null,

    init() {
        this.drop.addEventListener('click', ()=> this.fileInput.click());
        this.chooseBtn.addEventListener('click', ()=> this.fileInput.click());
        this.fileInput.addEventListener('change', (e)=> this.handleFileChange(e));
        this.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); this.drop.classList.add('dragover'); });
        this.drop.addEventListener('dragleave', ()=> this.drop.classList.remove('dragover'));
        this.drop.addEventListener('drop', (e)=>{ e.preventDefault(); this.drop.classList.remove('dragover'); this.handleFileDrop(e); });
        this.convertBtn.addEventListener('click', ()=> this.runConversion());
        this.toggleAssetIdToUrl.addEventListener('change', () => {
            this.assetUrlFormatContainer.style.display = this.toggleAssetIdToUrl.checked ? 'block' : 'none';
        });
        this.addMappingBtn.addEventListener('click', () => this.addMappingRow());
        this.exportConfigBtn.addEventListener('click', () => this.handleExportConfig());
        this.importConfigBtn.addEventListener('click', () => this.importConfigInput.click());
        this.importConfigInput.addEventListener('change', (e) => this.handleImportConfig(e));
    },

    handleExportConfig() {
        const config = {
            instanceMappings: this.getInstanceMappings(),
        };
        const jsonString = JSON.stringify(config, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        downloadFile(blob, 'instance-mappings.json');
        console.log("instance mappings exported.");
    },

    handleImportConfig(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const config = JSON.parse(e.target.result);
                this.applyConfig(config);
                console.log("instance mappings imported successfully.");
            } catch (err) {
                console.error("failed to parse config file:", err);
                alert('invalid or corrupt configuration file.');
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    },
    
    applyConfig(config) {
        this.mappingsList.innerHTML = '';
        const mappings = config.instanceMappings || config;

        if (mappings && typeof mappings === 'object') {
            for (const [from, to] of Object.entries(mappings)) {
                this.addMappingRow(from, to);
            }
        } else {
            console.warn("imported config is not a valid mapping object.");
        }
    },

    addMappingRow(from = '', to = '') {
        const item = document.createElement('div');
        item.className = 'mapping-item';

        const fromInput = document.createElement('input');
        fromInput.type = 'text';
        fromInput.placeholder = 'original classname';
        fromInput.value = from;

        const toInput = document.createElement('input');
        toInput.type = 'text';
        toInput.placeholder = 'new classname';
        toInput.value = to;

        const arrow = document.createElement('span');
        arrow.textContent = '→';

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-mapping-btn';
        removeBtn.innerHTML = '&times;';
        removeBtn.title = 'remove mapping';
        removeBtn.onclick = () => item.remove();
        
        item.appendChild(fromInput);
        item.appendChild(arrow);
        item.appendChild(toInput);
        item.appendChild(removeBtn);

        this.mappingsList.appendChild(item);
    },
    
    getInstanceMappings() {
        const mappings = {};
        const items = this.mappingsList.querySelectorAll('.mapping-item');
        items.forEach(item => {
            const inputs = item.querySelectorAll('input[type="text"]');
            const from = inputs[0].value.trim();
            const to = inputs[1].value.trim();
            if (from && to) {
                mappings[from] = to;
            }
        });
        return mappings;
    },

    setFile(file) {
        this.currentFile = file;
        if (file) {
            this.filenameEl.textContent = file.name;
            this.dropHint.style.display = 'none';
            this.convertBtn.disabled = false;
            this.statusText.textContent = 'ready';
            this.statusText.className = 'status-text ready';
        } else {
            this.filenameEl.textContent = '';
            this.dropHint.style.display = 'block';
            this.convertBtn.disabled = true;
            this.statusText.textContent = 'idle';
            this.statusText.className = 'status-text';
        }
    },

    handleFileChange(e) {
        const f = e.target.files && e.target.files[0];
        if (f) this.setFile(f);
    },

    handleFileDrop(e) {
        const f = e.dataTransfer.files && e.dataTransfer.files[0];
        if (f) this.setFile(f);
    },

    async runConversion() {
        if (!this.currentFile) { alert('please select a file first'); return; }
        activeConsole.innerHTML = '';
        try {
            this.statusText.textContent = 'reading file...';
            this.statusText.className = 'status-text';
            const ab = await this.currentFile.arrayBuffer();
            const bytes = new Uint8Array(ab);
            
            const convertFolders = this.toggleFolders.checked;
            const convertMeshParts = this.toggleMeshParts.checked;
            const instanceMappings = this.getInstanceMappings();
            const convertAssetIdToUrl = this.toggleAssetIdToUrl.checked;
            const assetUrlFormat = this.assetUrlFormatInput.value;
            const forceXml = this.toggleXml.checked;
            const forceBinary = this.toggleBinary.checked;
            const isXml = this.currentFile.name.toLowerCase().endsWith('.rbxlx');
            
            this.statusText.textContent = 'processing...';

            const out = fix_place(
                bytes,
                isXml,
                forceXml,
                forceBinary,
                convertFolders,
                instanceMappings,
                convertAssetIdToUrl,
                assetUrlFormat,
                convertMeshParts
            );

            const shouldOutputXml = (isXml && !forceBinary) || forceXml;
            const outname = shouldOutputXml 
                ? this.currentFile.name.replace(/\.rbxlx?$/i, '_fixed.rbxlx')
                : this.currentFile.name.replace(/\.rbxlx?$/i, '_fixed.rbxl');

            this.statusText.textContent = 'packaging...';
            downloadFile(out, outname);

            this.statusText.textContent = 'done!';
            this.statusText.className = 'status-text ready';
            setTimeout(() => {
                if(this.statusText.textContent === 'done!') {
                    this.statusText.textContent = 'ready';
                    this.statusText.className = 'status-text ready';
                }
            }, 2000);
        } catch(err) {
            console.error('conversion error:', err);
            this.statusText.textContent = 'error!';
            this.statusText.className = 'status-text error';
            alert('conversion error: ' + (err && err.message ? err.message : String(err)));
        }
    }
};

const objToMeshConverter = {
    dropHint: document.getElementById('drop-hint-obj-to-mesh'),
    filenameEl: document.getElementById('filename-obj-to-mesh'),
    drop: document.getElementById('drop-obj-to-mesh'),
    chooseBtn: document.getElementById('choosebtn-obj-to-mesh'),
    fileInput: document.getElementById('fileinput-obj-to-mesh'),
    convertBtn: document.getElementById('convertbtn-obj-to-mesh'),
    statusText: document.getElementById('status-text-obj-to-mesh'),
    versionSelect: document.getElementById('mesh-version-select'),
    currentFile: null,

    init() {
        this.drop.addEventListener('click', ()=> this.fileInput.click());
        this.chooseBtn.addEventListener('click', ()=> this.fileInput.click());
        this.fileInput.addEventListener('change', (e)=> this.handleFileChange(e));
        this.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); this.drop.classList.add('dragover'); });
        this.drop.addEventListener('dragleave', ()=> this.drop.classList.remove('dragover'));
        this.drop.addEventListener('drop', (e)=>{ e.preventDefault(); this.drop.classList.remove('dragover'); this.handleFileDrop(e); });
        this.convertBtn.addEventListener('click', ()=> this.runConversion());
    },

    setFile(file) {
        this.currentFile = file;
        if (file) {
            this.filenameEl.textContent = file.name;
            this.dropHint.style.display = 'none';
            this.convertBtn.disabled = false;
            this.statusText.textContent = 'ready';
            this.statusText.className = 'status-text ready';
        } else {
            this.filenameEl.textContent = '';
            this.dropHint.style.display = 'block';
            this.convertBtn.disabled = true;
            this.statusText.textContent = 'idle';
            this.statusText.className = 'status-text';
        }
    },

    handleFileChange(e) {
        const f = e.target.files && e.target.files[0];
        if (f) this.setFile(f);
    },

    handleFileDrop(e) {
        const f = e.dataTransfer.files && e.dataTransfer.files[0];
        if (f) this.setFile(f);
    },

    async runConversion() {
        if (!this.currentFile) { alert('please select a file first'); return; }
        activeConsole.innerHTML = '';
        try {
            this.statusText.textContent = 'reading file...';
            this.statusText.className = 'status-text';
            const ab = await this.currentFile.arrayBuffer();
            const bytes = new Uint8Array(ab);
            const versionString = this.versionSelect.value;
            
            const versionMap = {
                'v1.00': RobloxMeshVersion.V1_00,
                'v1.01': RobloxMeshVersion.V1_01,
                'v2.00': RobloxMeshVersion.V2_00,
                'v3.00': RobloxMeshVersion.V3_00,
                'v4.00': RobloxMeshVersion.V4_00,
                'v5.00': RobloxMeshVersion.V5_00,
            };
            const wasmVersion = versionMap[versionString];
            
            this.statusText.textContent = `processing with ${versionString}...`;
            
            const out = convert_obj_to_filemesh(bytes, wasmVersion);
            const outname = this.currentFile.name.replace(/\.obj$/i, '.mesh');

            this.statusText.textContent = 'packaging...';
            downloadFile(out, outname);

            this.statusText.textContent = 'done!';
            this.statusText.className = 'status-text ready';
            setTimeout(() => {
                if(this.statusText.textContent === 'done!') {
                    this.statusText.textContent = 'ready';
                    this.statusText.className = 'status-text ready';
                }
            }, 2000);
        } catch(err) {
            console.error('conversion error:', err);
            this.statusText.textContent = 'error!';
            this.statusText.className = 'status-text error';
            alert('conversion error: ' + (err && err.message ? err.message : String(err)));
        }
    }
};

const meshToObjConverter = {
    dropHint: document.getElementById('drop-hint-mesh-to-obj'),
    filenameEl: document.getElementById('filename-mesh-to-obj'),
    drop: document.getElementById('drop-mesh-to-obj'),
    chooseBtn: document.getElementById('choosebtn-mesh-to-obj'),
    fileInput: document.getElementById('fileinput-mesh-to-obj'),
    convertBtn: document.getElementById('convertbtn-mesh-to-obj'),
    statusText: document.getElementById('status-text-mesh-to-obj'),
    currentFile: null,

    init() {
        this.drop.addEventListener('click', ()=> this.fileInput.click());
        this.chooseBtn.addEventListener('click', ()=> this.fileInput.click());
        this.fileInput.addEventListener('change', (e)=> this.handleFileChange(e));
        this.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); this.drop.classList.add('dragover'); });
        this.drop.addEventListener('dragleave', ()=> this.drop.classList.remove('dragover'));
        this.drop.addEventListener('drop', (e)=>{ e.preventDefault(); this.drop.classList.remove('dragover'); this.handleFileDrop(e); });
        this.convertBtn.addEventListener('click', ()=> this.runConversion());
    },

    setFile(file) {
        this.currentFile = file;
        if (file) {
            this.filenameEl.textContent = file.name;
            this.dropHint.style.display = 'none';
            this.convertBtn.disabled = false;
            this.statusText.textContent = 'ready';
            this.statusText.className = 'status-text ready';
        } else {
            this.filenameEl.textContent = '';
            this.dropHint.style.display = 'block';
            this.convertBtn.disabled = true;
            this.statusText.textContent = 'idle';
            this.statusText.className = 'status-text';
        }
    },
    
    handleFileChange(e) {
        const f = e.target.files && e.target.files[0];
        if (f) this.setFile(f);
    },

    handleFileDrop(e) {
        const f = e.dataTransfer.files && e.dataTransfer.files[0];
        if (f) this.setFile(f);
    },

    async runConversion() {
        if (!this.currentFile) { alert('please select a file first'); return; }
        activeConsole.innerHTML = '';
        try {
            this.statusText.textContent = 'reading file...';
            this.statusText.className = 'status-text';
            const ab = await this.currentFile.arrayBuffer();
            const bytes = new Uint8Array(ab);
            
            this.statusText.textContent = `processing...`;
            
            const out = convert_filemesh_to_obj(bytes);
            const outname = this.currentFile.name.replace(/\.mesh$/i, '.obj');

            this.statusText.textContent = 'packaging...';
            downloadFile(out, outname);

            this.statusText.textContent = 'done!';
            this.statusText.className = 'status-text ready';
            setTimeout(() => {
                if(this.statusText.textContent === 'done!') {
                    this.statusText.textContent = 'ready';
                    this.statusText.className = 'status-text ready';
                }
            }, 2000);
        } catch(err) {
            console.error('conversion error:', err);
            this.statusText.textContent = 'error!';
            this.statusText.className = 'status-text error';
            alert('conversion error: ' + (err && err.message ? err.message : String(err)));
        }
    }
};

const meshVersionConverter = {
    dropHint: document.getElementById('drop-hint-mesh-version'),
    filenameEl: document.getElementById('filename-mesh-version'),
    drop: document.getElementById('drop-mesh-version'),
    chooseBtn: document.getElementById('choosebtn-mesh-version'),
    fileInput: document.getElementById('fileinput-mesh-version'),
    convertBtn: document.getElementById('convertbtn-mesh-version'),
    statusText: document.getElementById('status-text-mesh-version'),
    versionSelect: document.getElementById('mesh-version-select-target'),
    currentFile: null,

    init() {
        this.drop.addEventListener('click', ()=> this.fileInput.click());
        this.chooseBtn.addEventListener('click', ()=> this.fileInput.click());
        this.fileInput.addEventListener('change', (e)=> this.handleFileChange(e));
        this.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); this.drop.classList.add('dragover'); });
        this.drop.addEventListener('dragleave', ()=> this.drop.classList.remove('dragover'));
        this.drop.addEventListener('drop', (e)=>{ e.preventDefault(); this.drop.classList.remove('dragover'); this.handleFileDrop(e); });
        this.convertBtn.addEventListener('click', ()=> this.runConversion());
    },

    setFile(file) {
        this.currentFile = file;
        if (file) {
            this.filenameEl.textContent = file.name;
            this.dropHint.style.display = 'none';
            this.convertBtn.disabled = false;
            this.statusText.textContent = 'ready';
            this.statusText.className = 'status-text ready';
        } else {
            this.filenameEl.textContent = '';
            this.dropHint.style.display = 'block';
            this.convertBtn.disabled = true;
            this.statusText.textContent = 'idle';
            this.statusText.className = 'status-text';
        }
    },

    handleFileChange(e) {
        const f = e.target.files && e.target.files[0];
        if (f) this.setFile(f);
    },

    handleFileDrop(e) {
        const f = e.dataTransfer.files && e.dataTransfer.files[0];
        if (f) this.setFile(f);
    },

    async runConversion() {
        if (!this.currentFile) { alert('please select a file first'); return; }
        activeConsole.innerHTML = '';
        try {
            this.statusText.textContent = 'reading file...';
            this.statusText.className = 'status-text';
            const ab = await this.currentFile.arrayBuffer();
            const bytes = new Uint8Array(ab);
            const versionString = this.versionSelect.value;

            const versionMap = {
                'v1.00': RobloxMeshVersion.V1_00,
                'v1.01': RobloxMeshVersion.V1_01,
                'v2.00': RobloxMeshVersion.V2_00,
                'v3.00': RobloxMeshVersion.V3_00,
                'v4.00': RobloxMeshVersion.V4_00,
                'v5.00': RobloxMeshVersion.V5_00,
            };
            const wasmVersion = versionMap[versionString];

            this.statusText.textContent = `converting to ${versionString}...`;

            const out = convert_filemesh_version(bytes, wasmVersion);
            const outname = this.currentFile.name.replace(/(\.mesh)?$/i, `_${versionString}.mesh`);

            this.statusText.textContent = 'packaging...';
            downloadFile(out, outname);

            this.statusText.textContent = 'done!';
            this.statusText.className = 'status-text ready';
            setTimeout(() => {
                if(this.statusText.textContent === 'done!') {
                    this.statusText.textContent = 'ready';
                    this.statusText.className = 'status-text ready';
                }
            }, 2000);
        } catch(err) {
            console.error('conversion error:', err);
            this.statusText.textContent = 'error!';
            this.statusText.className = 'status-text error';
            alert('conversion error: ' + (err && err.message ? err.message : String(err)));
        }
    }
};

function downloadFile(data, filename) {
    const blob = (data instanceof Blob) ? data : new Blob([data], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
}

async function main() {
  try {
    await initWasm();
    placeConverter.init();
    objToMeshConverter.init();
    meshToObjConverter.init();
    meshVersionConverter.init();
  } catch (err) {
    console.error("failed to initialize wasm module:", err);
    alert('fatal error loading core components.');
  }
}

main();
</script>
</body>
</html>